#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Generate Jyutping dictionary entries using pyCantonese (Method 3).

This script is a **development-time tool**. It:
1. Reads an input CSV with Cantonese words / characters.
2. Uses pyCantonese to convert them to Jyutping.
3. Writes an SQL file that can be imported into MySQL
   to populate the `jyutping_dictionary` table.

Usage (from project root):

    # 1. Install dependencies in your Python environment:
    #    pip install pycantonese
    #
    # 2. Edit the input CSV if needed:
    #    backend/database/jyutping_pycantonese_input.csv
    #
    # 3. Generate SQL:
    #    python backend/scripts/generate-jyutping-from-pycantonese.py
    #
    # 4. Import into MySQL (reuse Method 1):
    #    mysql -h HOST -u USER -pPASSWORD cboard \
    #      < backend/database/seed-jyutping-from-pycantonese.sql
"""

import csv
import sys
from pathlib import Path

try:
    import pycantonese as pc
except ImportError:
    sys.stderr.write(
        "[ERROR] pycantonese is not installed. "
        "Please run: pip install pycantonese\n"
    )
    sys.exit(1)


PROJECT_ROOT = Path(__file__).resolve().parents[2]
INPUT_CSV = PROJECT_ROOT / "backend" / "database" / "jyutping_pycantonese_input.csv"
OUTPUT_SQL = PROJECT_ROOT / "backend" / "database" / "seed-jyutping-from-pycantonese.sql"


def hanzi_or_word_to_jyutping(text: str) -> str:
    """
    Convert Cantonese text (characters / words) to a single Jyutping string.

    - Uses pyCantonese.characters_to_jyutping, which returns a list of Jyutping
      syllables for each character.
    - We join them with spaces: e.g. 香港 -> hoeng1 gong2
    """
    if not text:
        return ""

    try:
        jp_list = pc.characters_to_jyutping(text)
    except Exception as e:
        sys.stderr.write(
            f"[WARN] Failed to convert text to Jyutping: '{text}' ({e})\n"
        )
        return ""

    # Flatten list and join
    # characters_to_jyutping may return nested lists depending on version;
    # we normalise to a flat list of strings.
    flat = []
    for item in jp_list:
        if isinstance(item, (list, tuple)):
            flat.extend(str(x) for x in item if x)
        elif item:
            flat.append(str(item))

    return " ".join(flat).strip()


def main() -> None:
    if not INPUT_CSV.exists():
        sys.stderr.write(
            f"[ERROR] Input CSV not found: {INPUT_CSV}\n"
            "Please create it based on the sample header:\n"
            "hanzi,word,frequency,tags\n"
        )
        sys.exit(1)

    rows = []
    with INPUT_CSV.open(encoding="utf-8") as f:
        reader = csv.DictReader(f)
        for idx, row in enumerate(reader, start=2):  # header = line 1
            hanzi = (row.get("hanzi") or "").strip()
            word = (row.get("word") or "").strip()
            freq_raw = (row.get("frequency") or "").strip()
            tags = (row.get("tags") or "").strip()

            if not hanzi and not word:
                # Nothing to convert on this line
                continue

            text = word or hanzi
            jyutping_code = hanzi_or_word_to_jyutping(text)

            if not jyutping_code:
                sys.stderr.write(
                    f"[WARN] No Jyutping generated for line {idx}: '{text}'\n"
                )
                continue

            try:
                frequency = int(freq_raw) if freq_raw else 200
            except ValueError:
                sys.stderr.write(
                    f"[WARN] Invalid frequency '{freq_raw}' on line {idx}, "
                    "using default 200\n"
                )
                frequency = 200

            rows.append(
                {
                    "jyutping_code": jyutping_code,
                    "hanzi": hanzi or None,
                    "word": word or None,
                    "frequency": frequency,
                    "tags": tags or None,
                }
            )

    if not rows:
        sys.stderr.write(
            "[WARN] No valid rows to write. "
            "Please check your input CSV content.\n"
        )
        sys.exit(0)

    OUTPUT_SQL.parent.mkdir(parents=True, exist_ok=True)

    with OUTPUT_SQL.open("w", encoding="utf-8") as out:
        out.write(
            "-- Auto-generated by generate-jyutping-from-pycantonese.py\n"
            "-- Source CSV: jyutping_pycantonese_input.csv\n"
            "-- This file can be imported with MySQL to extend jyutping_dictionary.\n\n"
        )
        out.write(
            "INSERT INTO `jyutping_dictionary` "
            "(`jyutping_code`, `hanzi`, `word`, `frequency`, `tags`) VALUES\n"
        )

        values_sql = []
        for r in rows:
            jyutping_sql = r["jyutping_code"].replace("'", "''")

            # Pre-escape strings to avoid complicated quoting in f-strings
            hanzi_escaped = r["hanzi"].replace("'", "''") if r["hanzi"] else None
            word_escaped = r["word"].replace("'", "''") if r["word"] else None
            tags_escaped = r["tags"].replace("'", "''") if r["tags"] else None

            hanzi_sql = f"'{hanzi_escaped}'" if hanzi_escaped is not None else "NULL"
            word_sql = f"'{word_escaped}'" if word_escaped is not None else "NULL"
            tags_sql = f"'{tags_escaped}'" if tags_escaped is not None else "NULL"

            values_sql.append(
                f"('{jyutping_sql}', {hanzi_sql}, {word_sql}, "
                f"{int(r['frequency'])}, {tags_sql})"
            )

        out.write(",\n".join(values_sql))
        out.write(
            "\nON DUPLICATE KEY UPDATE "
            "frequency = GREATEST(frequency, VALUES(frequency)), "
            "tags = VALUES(tags), "
            "updated_at = NOW();\n"
        )

    print(f"[OK] Generated SQL file: {OUTPUT_SQL}")
    print(f"[INFO] You can now import it into MySQL using Method 1.")


if __name__ == "__main__":
    main()


